{"name":"flow-control","components":[{"hidden":false,"type":"COMPONENT","displayName":"Flow Reference","description":"Executes a given subflow within the current flow. The subflow shares the same context of the calling flow. When completed the result Message of its execution is sent back to the original flow continuing its execution.","fullyQualifiedName":"com.reedelk.runtime.component.FlowReference","properties":[{"name":"ref","example":"1edc7e0d-6be9-46d9-8fa4-d64e3ea21de1","initValue":"###USE_DEFAULT_VALUE###","description":"The id of the referenced subflow","displayName":"Subflow Reference","type":{"classname":"com.reedelk.module.descriptor.model.TypePrimitiveDescriptor","instance":{"type":"java.lang.String"}},"whens":[],"autocompleteVariables":[]}]},{"hidden":false,"type":"COMPONENT","displayName":"For Each","description":"The For Each component applies to each element in the given collection the components following the For Each processor. A Join component can be added right outside the scope of the For Each to merge together all the results. If no Join component is present all the results after the execution are collected in a list.","fullyQualifiedName":"com.reedelk.runtime.component.ForEach","properties":[{"name":"collection","example":"\u003ccode\u003emessage.payload()\u003c/code\u003e","initValue":"#[message.payload()]","description":"The collection of items this component should loop through. For each item in the collection a new message is created with a payload containing a single item of the collection. The components following For Each will be executed with every message created out of the collection.","displayName":"Items collection","type":{"classname":"com.reedelk.module.descriptor.model.TypeDynamicValueDescriptor","instance":{"type":"com.reedelk.runtime.api.script.dynamicvalue.DynamicObject"}},"whens":[],"autocompleteVariables":[]}]},{"hidden":false,"type":"COMPONENT","displayName":"Fork","description":"This components copies the current flow message and sends each copy to every branch following the component. The execution of each branch is performed in parallel and the resulting messages from each execution can be merged by adding a Join component right after the fork scope. If the fork scope is not followed by any branch an empty flow message is set instead.","fullyQualifiedName":"com.reedelk.runtime.component.Fork","properties":[]},{"hidden":true,"type":"PROCESSOR","displayName":"Placeholder","fullyQualifiedName":"com.reedelk.runtime.component.Placeholder","properties":[]},{"hidden":false,"type":"COMPONENT","displayName":"Router","description":"A router component allows to execute only one of the branches following the component based on a given condition which must be defined for each branch. A default condition is mandatory, which represents the default branch to be executed when no other condition is met. A condition might be a function checking the content of the payload or the presence (or absence) of a specific attribute in the message and so on.","fullyQualifiedName":"com.reedelk.runtime.component.Router","properties":[{"name":"conditionAndRouteDefinitions","example":"\u003ccode\u003emessage.payload().contains(\u0027orders\u0027)\u003c/code\u003e","initValue":"###USE_DEFAULT_VALUE###","description":"For each route a dynamic value returning a boolean value must be specified. Each dynamic value is evaluated for each branch of the router to determine which branch has to be executed.","displayName":"Condition and route definitions","type":{"classname":"com.reedelk.module.descriptor.model.TypeDynamicMapDescriptor","instance":{"tabPlacement":"LEFT","type":"com.reedelk.runtime.api.script.dynamicmap.DynamicBooleanMap"}},"whens":[],"autocompleteVariables":[]}]},{"hidden":true,"type":"COMPONENT","displayName":"Stop","fullyQualifiedName":"com.reedelk.runtime.component.Stop","properties":[]},{"hidden":false,"type":"COMPONENT","displayName":"Try-Catch","description":"Allows to execute a sequence of components in the try branch and perform another sequence of components in the catch branch whenever an error is thrown by the execution of the components in the try.","fullyQualifiedName":"com.reedelk.runtime.component.TryCatch","properties":[]}],"autocompleteItems":[{"type":"Error","token":"getMessage","example":"error.getMessage()","signature":"getMessage()","returnType":"String","description":"Returns the error message.","cursorOffset":0,"itemType":"FUNCTION"},{"type":"Error","token":"toString","example":"error.toString()","signature":"toString()","returnType":"String","description":"Returns a string representation of the error.","cursorOffset":0,"itemType":"FUNCTION"},{"type":"FlowContext","token":"contains","example":"context.contains(\u0027myJson\u0027)","signature":"contains(key: String)","returnType":"boolean","description":"Checks whether an object with the given key exists in the context.","cursorOffset":1,"itemType":"FUNCTION"},{"type":"FlowContext","token":"get","example":"context.get(\u0027myJson\u0027)","signature":"get(key: String)","returnType":"Serializable","description":"Retrieves the object stored in the context given the key.","cursorOffset":1,"itemType":"FUNCTION"},{"type":"FlowContext","token":"put","example":"context.put(\u0027myJson\u0027, message.payload())","signature":"put(key: String, object: Serializable)","returnType":"Void","description":"Puts an object with the given key into the flow context.","cursorOffset":1,"itemType":"FUNCTION"},{"type":"FlowContext","token":"toString","example":"context.toString()","signature":"toString()","returnType":"String","description":"Returns a string representation of the flow context.","cursorOffset":0,"itemType":"FUNCTION"},{"type":"FlowContext","token":"correlationId","example":"context.correlationId","signature":"correlationId","returnType":"String","description":"Returns the current flow correlation id.","cursorOffset":0,"itemType":"VARIABLE"},{"type":"Message","token":"payload","example":"message.payload()","signature":"payload()","returnType":"Object","description":"Returns the payload (data) of the message. The payload could be a text, a byte array, a collection and so on depending on the component which generated it.","cursorOffset":0,"itemType":"FUNCTION"},{"type":"Message","token":"content","example":"message.content()","signature":"content()","returnType":"TypedContent","description":"Returns the content descriptor of this message. The message content contains information about the payload\u0027s mime type, data type and stream status.","cursorOffset":0,"itemType":"FUNCTION"},{"type":"Message","token":"attributes","example":"message.attributes()","signature":"attributes()","returnType":"MessageAttributes","description":"Returns the message attributes belonging to this message.","cursorOffset":0,"itemType":"FUNCTION"},{"type":"MessageAttributes","token":"get","example":"message.attributes().get(\u0027pathParams\u0027)","signature":"get(attributeKey: String)","returnType":"Serializable","description":"Given the attribute key, returns the attribute value associated with the given key.","cursorOffset":1,"itemType":"FUNCTION"},{"type":"MessageAttributes","token":"contains","example":"message.attributes().contains(\u0027pathParams\u0027)","signature":"contains(attributeKey: String)","returnType":"boolean","description":"If exists an attribute in the message attributes with the given key, returns true, false otherwise.","cursorOffset":1,"itemType":"FUNCTION"},{"type":"MimeType","token":"subType","example":"message.content().mimeType().subType()","signature":"subType()","returnType":"String","description":"Returns the sub-type of the mime type.","cursorOffset":0,"itemType":"FUNCTION"},{"type":"MimeType","token":"primaryType","example":"message.content().mimeType().primaryType()","signature":"primaryType()","returnType":"String","description":"Returns the primary type of the mime type.","cursorOffset":0,"itemType":"FUNCTION"},{"type":"MimeType","token":"fileExtensions","example":"message.content().mimeType().fileExtensions()","signature":"fileExtensions()","returnType":"List","description":"Returns a list of file extensions associated to this mime type.","cursorOffset":0,"itemType":"FUNCTION"},{"type":"Part","token":"name","example":"part.name()","signature":"name()","returnType":"String","description":"Returns the name of the part object.","cursorOffset":0,"itemType":"FUNCTION"},{"type":"Part","token":"content","example":"part.content()","signature":"content()","returnType":"TypedContent","description":"Returns content of the part object.","cursorOffset":0,"itemType":"FUNCTION"},{"type":"Part","token":"attributes","example":"part.attributes()","signature":"attributes()","returnType":"Map","description":"Returns the attributes of the part object.","cursorOffset":0,"itemType":"FUNCTION"},{"type":"Parts","token":"get","example":"parts.get(\u0027file\u0027)","signature":"get(partName: String)","returnType":"Part","description":"Returns the part object with the given partName.","cursorOffset":1,"itemType":"FUNCTION"},{"type":"Parts","token":"put","example":"parts.put(\u0027file\u0027, part)","signature":"put(partName: String, part: Part)","returnType":"Void","description":"Puts the part object into the parts map with the given partName.","cursorOffset":1,"itemType":"FUNCTION"},{"type":"ResultRow","token":"columnCount","example":"row.columnCount()","signature":"columnCount()","returnType":"int","description":"Returns the number of columns in this row.","cursorOffset":0,"itemType":"FUNCTION"},{"type":"ResultRow","token":"columnName","example":"row.columnName(4)","signature":"columnName(index: int)","returnType":"String","description":"Given the column index, returns the column name at the given index.","cursorOffset":1,"itemType":"FUNCTION"},{"type":"ResultRow","token":"columnNames","example":"row.columnNames()","signature":"columnNames()","returnType":"List","description":"Returns a list containing all column names of this database row.","cursorOffset":1,"itemType":"FUNCTION"},{"type":"ResultRow","token":"get","example":"row.get(3)","signature":"get(index: int)","returnType":"Object","description":"Given the column index, returns the value of the row at the given index.","cursorOffset":1,"itemType":"FUNCTION"},{"type":"ResultRow","token":"getByName","example":"row.getByName(\u0027id\u0027)","signature":"getByName(columnName: String)","returnType":"Object","description":"Given the column name, returns the value of the row from the given column name.","cursorOffset":1,"itemType":"FUNCTION"},{"type":"ResultRow","token":"row","example":"row.row()","signature":"row()","returnType":"List","description":"Returns a list containing all the values belonging to this row.","cursorOffset":0,"itemType":"FUNCTION"},{"type":"TypedContent","token":"type","example":"message.content().type()","signature":"type()","returnType":"Class","description":"Returns the data type of the content.","cursorOffset":0,"itemType":"FUNCTION"},{"type":"TypedContent","token":"mimeType","example":"message.content().mimeType()","signature":"mimeType()","returnType":"MimeType","description":"Returns the mime type of the content.","cursorOffset":0,"itemType":"FUNCTION"},{"type":"TypedContent","token":"data","example":"message.content().data()","signature":"data()","returnType":"Object","description":"Returns the actual data which could be could be a text, a byte array, a collection and so on depending on the component which generated it.","cursorOffset":0,"itemType":"FUNCTION"},{"type":"TypedContent","token":"isStream","example":"message.content().isStream()","signature":"isStream()","returnType":"boolean","description":"Returns true if this message is a stream, false otherwise.","cursorOffset":0,"itemType":"FUNCTION"},{"type":"TypedContent","token":"isConsumed","example":"message.content().isConsumed()","signature":"isConsumed()","returnType":"boolean","description":"Returns true if this message stream has been consumed, false otherwise. When a stream has been consumed it means that all stream data has been loaded into memory.","cursorOffset":0,"itemType":"FUNCTION"},{"type":"TypedContent","token":"consume","example":"message.content().consume()","signature":"consume()","returnType":"void","description":"Consumes the stream of this message by loading the entire stream content into memory.","cursorOffset":0,"itemType":"FUNCTION"}],"autocompleteTypes":[{"global":false,"type":"Error","description":"The Error type encapsulates an error."},{"global":false,"type":"FlowContext","description":"The FlowContext type encapsulates the execution context for a flow. The execution context allows to store and retrieve data which can be accessed by components during the execution of a flow. For example the correlation id which is a unique identifier generated every time a flow is executed."},{"global":false,"type":"Message","description":"The Message encapsulates data and attributes passing through the components of a flow."},{"global":false,"type":"MessageAttributes","description":"The message attributes type contains attributes set by processors in the out message after their execution. Message attributes contain information collected during the execution of a given component. For example, the REST Listener sets in the attributes request\u0027s path parameters, query parameters, HTTP headers and so on."},{"global":false,"type":"MimeType","description":"A mime type encapsulates information about the mime type of the content. A mime type is composed by a primary type (e.g image) and by a sub type (e.g jpeg)."},{"global":false,"type":"Part","description":"The Part type encapsulate a REST Part object."},{"global":false,"type":"Parts","description":"The Parts type contains all the parts composing a REST Multipart payload."},{"global":false,"type":"ResultRow","description":"The ResultRow type encapsulates a database row."},{"global":false,"type":"TypedContent","description":"A typed content contains information about the payload which encapsulates. Information provided by type are payload type (e.g String, Object, Collection), mime type (e.g text/plain, image/jpeg), and the actual content data."}]}